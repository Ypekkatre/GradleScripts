buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }

    dependencies {
        classpath "net.dumbcode.gradlehook:GradleHook:1.3.1"
        classpath "net.darkhax.curseforgegradle:CurseForgeGradle:1.0.11"
        classpath "org.kohsuke:github-api:1.114"
        classpath "org.ajoberstar.grgit:grgit-gradle:5.3.0"
        classpath "com.modrinth.minotaur:Minotaur:2.4.4"
    }
}


//buildscript.configurations.classpath.each { println it }

apply plugin: net.dumbcode.gradlehook.GradleWebhookPlugin
apply plugin: net.darkhax.curseforgegradle.CurseForgeGradlePlugin
apply plugin: org.ajoberstar.grgit.gradle.GrgitPlugin
apply plugin: com.modrinth.minotaur.Minotaur
apply plugin: 'maven-publish'

import javax.net.ssl.HttpsURLConnection
import java.nio.file.Files

archivesBaseName = project.archives_base_name
ext.versionDisplay = "${project.minecraft_version}-${getVersion()}"

ext.additionalProperties = new Properties()
if (file("extra.properties").exists()) {
    additionalProperties.load(file("extra.properties").newReader())
}

def getVersion() {
    if (project.hasProperty('currentTag')) {
        if (project.currentTag.startsWith("v")) {
            return project.currentTag.substring(1)
        }
        return project.currentTag
    }
    return project.mod_version
}

tasks.withType(JavaCompile) {
	options.encoding = "UTF-8"
}

ext.curseReleaseType = "release"
ext.releaseChangelog = "No Changelog Available"
ext.stabilitySuffix = ""
ext.curseforgeDownloadLink = null
ext.modrinthDownloadLink = null
ext.githubDownloadLink = null
ext.releaseType = project.default_release_type

ext.mainFile = null


// https://github.com/TerraformersMC/GradleScripts/blob/2.5/ferry.gradle#L35
task generateChangelog {
    def changes = StringBuilder.newInstance()
    if (!project.hasProperty("lastTag") || !project.hasProperty("currentTag")) {
        println "Missing lastTag or currentTag parameters, aborting changelog creation"
        return;
    }
    def lastTag = project.getProperty("lastTag")
    def currentTag = project.getProperty("currentTag")
    def commits = "git log --max-count=$project.changelog_max_commit_search --pretty=format:\"%b\" $lastTag..$currentTag".execute()
    println "Last version: $lastTag"
    println "Current version: $currentTag"

    if (currentTag.contains("-alpha")) {
        releaseType = "alpha"
        curseReleaseType = "alpha"
        stabilitySuffix = " (Alpha)"
    } else if (currentTag.contains("-beta")) {
        releaseType = "beta"
        curseReleaseType = "beta"
        stabilitySuffix = " (Beta)"
    } else if (currentTag.contains("-pre")) {
        releaseType = "pre"
        curseReleaseType = "beta"
        stabilitySuffix = " (Pre-Release)"
    } else if (currentTag.contains("-rc")) {
        releaseType = "rc"
        curseReleaseType = "beta"
        stabilitySuffix = " (Release Candidate)"
    } else if (!currentTag.contains("-")) {
        releaseType = "stable"
    }
    println "Release type: $releaseType"

    commits.in.eachLine { line -> // Loops over the lines the git log command returns
        def processedLine = line.toString()
        if (processedLine.startsWith("\"")) {
            processedLine = processedLine.substring(1)
        }
        if (processedLine.endsWith("\"")) {
            processedLine = processedLine.substring(0, processedLine.length() - 1)
        }
        println "Reading line: $processedLine"

        if (processedLine.startsWith("- ")) {
            println "Adding changelog line:"
            println "  $processedLine"
            if (changes.length() == 0) {
                changes << processedLine
            } else {
                changes << "\n$processedLine"
            }
        }
    }
    commits.err.eachLine { line -> println line }
    commits.waitFor()
    println "Changelog:"
    releaseChangelog = changes.toString()
    if (releaseChangelog.isEmpty()) {
        releaseChangelog = "No Changelog Available"
    }
    println releaseChangelog
}


String getBranch() {
    def ENV = System.getenv()
    if (ENV.GITHUB_REF) {
        def branch = ENV.GITHUB_REF
        return branch.substring(branch.lastIndexOf("/") + 1)
    }

    if (grgit == null) {
        return "unknown"
    }

    def branch = grgit.branch.current().name
    return branch.substring(branch.lastIndexOf("/") + 1)
}

task github {
	dependsOn build

    doLast {
        String gh_token
		if (additionalProperties["github_token"] != null) {
			gh_token = additionalProperties["github_token"]
		} else if (System.getenv("github_token") != null) {
			gh_token = System.getenv("github_token")
		} else {
			System.out.println("No GitHub token found...")
			return
		}
        def github = org.kohsuke.github.GitHub.connectUsingOAuth(gh_token as String)
        def repository = github.getRepository(System.getenv().GITHUB_REPOSITORY)

        def releaseBuilder = new org.kohsuke.github.GHReleaseBuilder(repository, project.getProperty("currentTag"))
        releaseBuilder.name("$project.project_name v$version for $project.minecraft_version")
        releaseBuilder.body(releaseChangelog)
        releaseBuilder.commitish(getBranch())
        if (releaseType != "stable") {
            releaseBuilder.prerelease(true)
        }

        def ghRelease = releaseBuilder.create()
        ghRelease.uploadAsset(((AbstractArchiveTask) remapJar).getArchiveFile().get().getAsFile(), "application/java-archive");
        githubDownloadLink = ghRelease.getHtmlUrl()
    }
}

task publishThirdParty {
    dependsOn 'github'
    tasks.findByName('github').mustRunAfter 'generateChangelog'
}
